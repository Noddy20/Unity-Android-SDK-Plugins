package com.arupakaman.pluginbasicutils.utils

import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.util.Log
import java.io.BufferedReader
import java.io.File
import java.io.IOException
import java.io.InputStreamReader
import java.util.*
import kotlin.NoSuchElementException
import kotlin.collections.ArrayList
import kotlin.collections.HashMap

// Thanks to https://github.com/scottyab/rootbeer

class RootChecker(private val mContext: Context) {

    /**
     * Run all the root detection checks.
     *
     * @return true, we think there's a good *indication* of root | false good *indication* of no root (could still be cloaked)
     */
    fun isRooted(): Boolean {
        return (checkForSuBinary()
                || checkForDangerousProps() || checkForRWPaths()
                || detectTestKeys() || checkSuExists() || checkForMagiskBinary())
    }

    /**
     * Run all the checks including checking for the busybox binary.
     * Warning: Busybox binary is not always an indication of root, many manufacturers leave this
     * binary on production devices
     * @return true, we think there's a good *indication* of root | false good *indication* of no root (could still be cloaked)
     */
    fun isPotentiallyDangerousAppsInstalled(list: List<String>?): Boolean {
        return (detectRootManagementApps()
                || detectPotentiallyDangerousApps()
                || detectRootCloakingApps()
                || isAnyPackageFromListInstalled(list?: emptyList()))
    }

    /**
     * Release-Keys and Test-Keys has to do with how the kernel is signed when it is compiled.
     * Test-Keys means it was signed with a custom key generated by a third-party developer.
     * @return true if signed with Test-keys
     */
    private fun detectTestKeys(): Boolean {
        val buildTags = Build.TAGS
        val result = buildTags != null && buildTags.contains("test-keys")
        Log.d("RootChecker", "detectTestKeys result->$result")
        return result
    }

    /**
     * Using the PackageManager, check for a list of well known root apps. @link {Const.knownRootAppsPackages}
     * @return true if one of the apps it's installed
     */
    private fun detectRootManagementApps(): Boolean {
        val result = isAnyPackageFromListInstalled(knownRootAppsPackages)
        Log.d("RootChecker", "detectRootManagementApps result->$result")
        return result
    }

    /**
     * Using the PackageManager, check for a list of well known apps that require root. @link {Const.knownRootAppsPackages}
     * @return true if one of the apps it's installed
     */
    private fun detectPotentiallyDangerousApps(): Boolean {
        val result = isAnyPackageFromListInstalled(knownDangerousAppsPackages)
        Log.d("RootChecker", "detectPotentiallyDangerousApps result->$result")
        return result
    }

    /**
     * Using the PackageManager, check for a list of well known root cloak apps. @link {Const.knownRootAppsPackages}
     * @param additionalRootCloakingApps - array of additional packagenames to search for
     * @return true if one of the apps it's installed
     */
    private fun detectRootCloakingApps(): Boolean {
        val result = isAnyPackageFromListInstalled(knownRootCloakingPackages)
        Log.d("RootChecker", "detectRootCloakingApps result->$result")
        return result
    }

    private fun checkForSuBinary(): Boolean {
        val result = checkForBinary(BINARY_SU)
        Log.d("RootChecker", "checkForSuBinary result->$result")
        return result
    }

    /**
     * Checks various (Const.suPaths) common locations for the magisk binary (a well know root level program)
     * @return true if found
     */
    private fun checkForMagiskBinary(): Boolean {
        val result = checkForBinary("magisk")
        Log.d("RootChecker", "checkForMagiskBinary result->$result")
        return result
    }

    /**
     * Checks various (Const.suPaths) common locations for the busybox binary (a well know root level program)
     * @return true if found
     */
    private fun checkForBusyBoxBinary(): Boolean {
        val result = checkForBinary(BINARY_BUSYBOX)
        Log.d("RootChecker", "checkForBusyBoxBinary result->$result")
        return result
    }

    /**
     *
     * @param filename - check for this existence of this file
     * @return true if found
     */
    private fun checkForBinary(filename: String): Boolean {
        val pathsArray: List<String> = getPaths()
        var result = false
        for (path in pathsArray) {
            val completePath = path + filename
            val f = File(path, filename)
            val fileExists: Boolean = f.exists()
            if (fileExists) {
                Log.v("RootChecker", "$completePath binary detected!")
                result = true
            }
        }
        return result
    }

    private fun propsReader(): Array<String>? {
        return try {
            val inputstream = Runtime.getRuntime().exec("getprop").inputStream
                ?: return null
            val propVal: String = Scanner(inputstream).useDelimiter("\\A").next()
            propVal.split("\n").toTypedArray()
        } catch (e: IOException) {
            Log.e("RootChecker", "propsReader $e")
            null
        } catch (e: NoSuchElementException) {
            Log.e("RootChecker", "propsReader $e")
            null
        }
    }

    private fun mountReader(): Array<String>? {
        return try {
            val inputStream = Runtime.getRuntime().exec("mount").inputStream ?: return null
            val propVal: String = Scanner(inputStream).useDelimiter("\\A").next()
            propVal.split("\n").toTypedArray()
        } catch (e: IOException) {
            Log.e("RootChecker", "mountReader $e")
            null
        } catch (e: NoSuchElementException) {
            Log.e("RootChecker", "mountReader $e")
            null
        }
    }

    /**
     * Check if any package in the list is installed
     * @param packages - list of packages to search for
     * @return true if any of the packages are installed
     */
    private fun isAnyPackageFromListInstalled(packages: List<String>): Boolean {
        var result = false
        val pm = mContext.packageManager
        for (packageName in packages) {
            try {
                // Root app detected
                pm.getPackageInfo(packageName, 0)
                Log.e("RootChecker", "$packageName ROOT management app detected!")
                result = true
            } catch (e: PackageManager.NameNotFoundException) {
                // Exception thrown, package is not installed into the system
            }
        }
        Log.d("RootChecker", "isAnyPackageFromListInstalled result->$result")
        return result
    }

    /**
     * Checks for several system properties for
     * @return - true if dangerous props are found
     */
    private fun checkForDangerousProps(): Boolean {
        val dangerousProps: MutableMap<String, String> = HashMap()
        dangerousProps["ro.debuggable"] = "1"
        dangerousProps["ro.secure"] = "0"
        var result = false
        val lines = propsReader() ?: return result
        for (line in lines) {
            for (key in dangerousProps.keys) {
                if (line.contains(key)) {
                    var badValue = dangerousProps[key]
                    badValue = "[$badValue]"
                    if (line.contains(badValue)) {
                        Log.v("RootChecker", "$key = $badValue detected!")
                        result = true
                    }
                }
            }
        }
        Log.d("RootChecker", "checkForDangerousProps result->$result")
        return result
    }

    /**
     * When you're root you can change the permissions on common system directories, this method checks if any of these patha Const.pathsThatShouldNotBeWritable are writable.
     * @return true if one of the dir is writable
     */
    private fun checkForRWPaths(): Boolean {
        var result = false
        val lines = mountReader() ?: return result

        val sdkVersion = Build.VERSION.SDK_INT

        for (line in lines) {

            // Split lines into parts
            val args = line.split(" ").toTypedArray()
            if (sdkVersion <= Build.VERSION_CODES.M && args.size < 4
                || sdkVersion > Build.VERSION_CODES.M && args.size < 6
            ) {
                // If we don't have enough options per line, skip this and log an error
                Log.e("RootChecker", "Error formatting mount line: $line")
                continue
            }
            var mountPoint: String
            var mountOptions: String
            /**
             * To check if the device is running Android version higher than Marshmallow or not
             */
            if (sdkVersion > Build.VERSION_CODES.M) {
                mountPoint = args[2]
                mountOptions = args[5]
            } else {
                mountPoint = args[1]
                mountOptions = args[3]
            }
            for (pathToCheck in pathsThatShouldNotBeWritable) {
                if (mountPoint.equals(pathToCheck, ignoreCase = true)) {
                    /**
                     * If the device is running an Android version above Marshmallow,
                     * need to remove parentheses from options parameter;
                     */
                    if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
                        mountOptions = mountOptions.replace("(", "")
                        mountOptions = mountOptions.replace(")", "")
                    }

                    // Split options out and compare against "rw" to avoid false positives
                    for (option in mountOptions.split(",").toTypedArray()) {
                        if (option.equals("rw", ignoreCase = true)) {
                            Log.v("RootChecker", "$pathToCheck path is mounted with rw permissions! $line")
                            result = true
                            break
                        }
                    }
                }
            }
        }
        Log.d("RootChecker", "checkForRWPaths result->$result")
        return result
    }


    /**
     * A variation on the checking for SU, this attempts a 'which su'
     * @return true if su found
     */

    private fun checkSuExists(): Boolean {
        var process: Process? = null
        return try {
            process = Runtime.getRuntime().exec(arrayOf("which", BINARY_SU))
            val result = BufferedReader(InputStreamReader(process.inputStream)).readLine() != null
            Log.d("RootChecker", "checkSuExists result->$result")
            result
        } catch (t: Throwable) {
            Log.e("RootChecker", "checkSuExists Exc $t")
            false
        } finally {
            process?.destroy()
        }
    }




    companion object{

        const val BINARY_SU = "su"
        const val BINARY_BUSYBOX = "busybox"

        val knownRootAppsPackages = listOf(
            "com.noshufou.android.su",
            "com.noshufou.android.su.elite",
            "eu.chainfire.supersu",
            "com.koushikdutta.superuser",
            "com.thirdparty.superuser",
            "com.yellowes.su",
            "com.topjohnwu.magisk",
            "com.kingroot.kinguser",
            "com.kingo.root",
            "com.smedialink.oneclickroot",
            "com.zhiqupk.root.global",
            "com.alephzain.framaroot"
        )

        val knownDangerousAppsPackages = listOf(
            "com.koushikdutta.rommanager",
            "com.koushikdutta.rommanager.license",
            "com.dimonvideo.luckypatcher",
            "com.chelpus.lackypatch",
            "com.ramdroid.appquarantine",
            "com.ramdroid.appquarantinepro",
            "com.android.vending.billing.InAppBillingService.COIN",
            "com.android.vending.billing.InAppBillingService.LUCK",
            "com.chelpus.luckypatcher",
            "com.blackmartalpha",
            "org.blackmart.market",
            "com.allinone.free",
            "com.repodroid.app",
            "org.creeplays.hack",
            "com.baseappfull.fwd",
            "com.zmapp",
            "com.dv.marketmod.installer",
            "org.mobilism.android",
            "com.android.wp.net.log",
            "com.android.camera.update",
            "cc.madkite.freedom",
            "com.solohsu.android.edxp.manager",
            "org.meowcat.edxposed.manager",
            "com.xmodgame",
            "com.cih.game_cih",
            "com.charles.lpoqasert",
            "catch_.me_.if_.you_.can_"
        )

        val knownRootCloakingPackages = listOf(
            "com.devadvance.rootcloak",
            "com.devadvance.rootcloakplus",
            "de.robv.android.xposed.installer",
            "com.saurik.substrate",
            "com.zachspong.temprootremovejb",
            "com.amphoras.hidemyroot",
            "com.amphoras.hidemyrootadfree",
            "com.formyhm.hiderootPremium",
            "com.formyhm.hideroot"
        )

        // These must end with a /
        val suPaths = listOf(
            "/data/local/",
            "/data/local/bin/",
            "/data/local/xbin/",
            "/sbin/",
            "/su/bin/",
            "/system/bin/",
            "/system/bin/.ext/",
            "/system/bin/failsafe/",
            "/system/sd/xbin/",
            "/system/usr/we-need-root/",
            "/system/xbin/",
            "/cache/",
            "/data/",
            "/dev/"
        )

        val pathsThatShouldNotBeWritable = listOf(
            "/system",
            "/system/bin",
            "/system/sbin",
            "/system/xbin",
            "/vendor/bin",
            "/sbin",
            "/etc"
        )

        /**
         * Get a list of paths to check for binaries
         *
         * @return List of paths to check, using a combination of a static list and those paths
         * listed in the PATH environment variable.
         */

        fun getPaths(): List<String>{
            var paths: ArrayList<String> = ArrayList(suPaths)
            kotlin.runCatching {
                val sysPaths = System.getenv("PATH")
                // If we can't get the path variable just return the static paths
                if (!sysPaths.isNullOrEmpty()) {
                    sysPaths.split(":").toTypedArray().forEach {path->
                        if (!path.endsWith("/") && !paths.contains("$path/")) {
                            paths.add(path)
                        }
                    }
                }
            }.onFailure {
                paths = arrayListOf()
                Log.e("RootChecker", "getPaths Exc $it")
            }
            return paths
        }

    }

}